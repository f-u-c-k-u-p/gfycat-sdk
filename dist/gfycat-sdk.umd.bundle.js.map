{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9d5186bb2329305717c6","webpack:///./~/qs/lib/formats.js","webpack:///./~/qs/lib/utils.js","webpack:///./~/qs/lib/index.js","webpack:///./src/util/http_browser.js","webpack:///./~/qs/lib/parse.js","webpack:///./~/qs/lib/stringify.js","webpack:///./src/es5-gfycat-sdk.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,OAAO,WAAW,aAAa;AACjD;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzMA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACVA;;AAEA;AACA;AACA,mBAAmB;AACnB,sBAAsB,OAAO;AAC7B,yBAAyB,OAAO;AAChC,wBAAwB,OAAO;AAC/B,yBAAyB,OAAO;AAChC,qBAAqB,OAAO;AAC5B,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;AC/DA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC7KA;;AAEA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA,KAAK;AACL,4CAA4C;AAC5C;AACA,KAAK;AACL,qCAAqC;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACjNA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA","file":"gfycat-sdk.umd.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GfycatSDK\"] = factory();\n\telse\n\t\troot[\"GfycatSDK\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9d5186bb2329305717c6","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nmodule.exports = {\n    'default': 'RFC3986',\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return value;\n        }\n    },\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/qs/lib/formats.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    var obj;\n\n    while (queue.length) {\n        var item = queue.pop();\n        obj = item.obj[item.prop];\n\n        if (Array.isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n\n    return obj;\n};\n\nexports.arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    if (Array.isArray(target) && Array.isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                if (target[i] && typeof target[i] === 'object') {\n                    target[i] = exports.merge(target[i], item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function encode(str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    return compactQueue(queue);\n};\n\nexports.isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function isBuffer(obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/qs/lib/utils.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/qs/lib/index.js\n// module id = 2\n// module chunks = 0","/* globals XMLHttpRequest */\n\n/**\n * Browser based http request\n * @param options {Object}\n *   options.request {Object} - Request data\n *      request.headers {Object} - (optional) HTTP headers to be sent with the request\n *      request.method {String} - HTTP method\n *      request.payload {Object} - (optional) JSON data to be sent with POST request\n *      request.url {String} - API url\n *   options.timeout {Number} - (optional) Request timeout before returning an error. Defaults to 30000 milliseconds\n */\nexports.request = function(options, resolve, reject) {\n  var timeout = options.timeout || 30000;\n\n  var timer = setTimeout(function() {\n    xhr.abort();\n    reject(new Error('API request exceeded timeout of', timeout));\n  }, timeout);\n\n  var xhr = new XMLHttpRequest();\n\n  function handleError(err) {\n    clearTimeout(timer);\n    err = err || new Error('API request failed');\n    reject(err);\n  }\n\n  function handleResponse(res) {\n    clearTimeout(timer);\n\n    if (xhr.status >= 400) return reject(xhr.status);\n\n    var body = xhr.response;\n    try {\n      body = JSON.parse(body);\n      resolve(body)\n    } catch (e) {\n      reject(e)\n    }\n  }\n\n  xhr.addEventListener('error', handleError);\n  xhr.addEventListener('abort', handleError);\n  xhr.addEventListener('load', handleResponse);\n\n  xhr.open(options.request.method, options.request.url, true);\n\n  var headers = options.request.headers || null;\n  if (headers) {\n    Object.keys(headers).forEach(function(header) {\n      xhr.setRequestHeader(header, headers[header])\n    })\n  }\n\n  var data = JSON.stringify(options.request.payload) || null;\n\n  if (!data) {\n    xhr.send();\n  } else {\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    xhr.send(data);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/http_browser.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    parameterLimit: 1000,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder);\n            val = options.decoder(part.slice(pos + 1), defaults.decoder);\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]') {\n            obj = [];\n            obj = obj.concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts ? utils.assign({}, opts) : {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;\n    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/qs/lib/parse.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\n        return prefix;\n    }\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaults = {\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar stringify = function stringify( // eslint-disable-line func-name-matching\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(\n                obj[key],\n                generateArrayPrefix(prefix, key),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly\n            ));\n        } else {\n            values = values.concat(stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly\n            ));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts ? utils.assign({}, opts) : {};\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;\n    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;\n    if (typeof options.format === 'undefined') {\n        options.format = formats['default'];\n    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {\n        throw new TypeError('Unknown format option provided.');\n    }\n    var formatter = formats.formatters[options.format];\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            strictNullHandling,\n            skipNulls,\n            encode ? encoder : null,\n            filter,\n            sort,\n            allowDots,\n            serializeDate,\n            formatter,\n            encodeValuesOnly\n        ));\n    }\n\n    var joined = keys.join(delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/qs/lib/stringify.js\n// module id = 5\n// module chunks = 0","var queryString = require('qs');\nvar httpService = require('./util/http_browser');\n\nvar API_HOSTNAME = 'https://api.gfycat.com';\nvar API_BASE_PATH = '/v1';\n\n// Check for Promise support\nvar promisesExist = typeof Promise !== 'undefined';\n\n/**\n * @callback requestCallback - callback function to run when the request completes.\n * @param {Error} error\n * @param response\n */\n\n/**\n * Error handler that supports promises and callbacks\n * @param {string} err - Error message\n * @param {requestCallback} callback\n * @ignore\n */\nfunction _handleErr(err, callback) {\n  if (callback) {\n    return callback(err);\n  } else if (promisesExist) {\n    return Promise.reject(err);\n  } else {\n    throw new Error(err);\n  }\n}\n\n\n/**\n * @param {Object} options\n * @param {string} options.client_id - Gfycat API client id.\n * @param {string} options.client_secret - Gfycat API secret.\n * @param {number} options.timeout - (optional) API timeout limit in milliseconds (default is 30000).\n * @class\n */\nvar GfycatSDK = function(options) {\n  if (typeof options === 'object' && options.hasOwnProperty('client_id') && options.hasOwnProperty('client_secret')) {\n    this.client_id = options.client_id;\n    this.client_secret = options.client_secret;\n    this.timeout = options.timeout || 30000;\n  } else if (typeof options === 'undefined' || !options) {\n    console.error('Although some of our API endpoints can be used without an API key, in order to get the best experience, we strongly recommend that you obtain an API key and initialize this SDK with the provided client_id and client_secret. Get your API key today by visiting https://developers.gfycat.com/signup');\n    API_BASE_PATH = '/v1test';\n  } else {\n    throw new Error('Please provide a valid options object with client_id and client_secret.')\n  }\n\n  this.apiUrl = API_HOSTNAME + API_BASE_PATH;\n  this.retryLimit = 2;\n};\n\n\nGfycatSDK.prototype = {\n  /**\n   * Retrieve Oauth token.\n   *\n   * @param options - (optional if id and secret were provided in constructor)\n   * @param {string} options.client_id - Gfycat client id.\n   * @param {string} options.client_secret - Gfycat client secret.\n   * @param {string} options.grant_type - Oauth grant type. 'client_credentials' by default.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  authenticate: function(options, callback) {\n    if (!options) options = {};\n    if (!(this.client_id || this.client_secret) && !(options.client_id || options.client_secret)) {\n      return _handleErr('Please provide client_id and client_secret in options', callback);\n    }\n\n    var options = {\n      api: '/oauth',\n      endpoint: '/token',\n      method: 'POST',\n      payload: {\n        client_id: options.client_id || this.client_id,\n        client_secret: options.client_secret || this.client_secret,\n        grant_type: options.grant_type || 'client_credentials'\n      }\n    }\n\n    var self = this;\n\n    if (callback) {\n      return this._request(options, function(err, res) {\n        if (!err) {\n          self._setToken(res);\n          callback(null, res);\n        } else callback(err);\n      })\n    } else {\n      return this._request(options)\n        .then(function(res) {\n          self._setToken(res);\n          Promise.resolve(res);\n        })\n        .catch(function(err) {\n          Promise.reject(err);\n        })\n    }\n  },\n\n  /**\n   * Retrieve JSON array of reactions/categories.\n   *\n   * @param {Object} options\n   * @param {number} options.gfyCount - number of GIFs to include per category.\n   * @param {string} options.locale - locale for requested language.\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getCategories: function getCategories(options, callback) {\n    if (!options) options = {};\n\n    return this._request({\n      api: '/reactions',\n      endpoint: '/populated',\n      method: 'GET',\n      query: {\n        gfyCount: options.gfyCount || 1,\n        count: options.count || null,\n        cursor: options.cursor || null,\n        locale: options.locale || null\n      }\n    }, callback);\n  },\n\n  /**\n   * Retrieve JSON array of GIFs in a specific category/reaction specified by tagName.\n   *\n   * Note: with the exception of \"trending\" category,\n   * GIFs belonging to all other reaction categories can be retrieved using the search endpoint.\n   * If the search term used is a category/reaction name, the search API will automatically give\n   * precedence to GIFs that belong in that category.\n   *\n   * @param {Object} options\n   * @param {number} options.gfyCount - number of GIFs to return.\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {string} options.tagName - name of the category/reaction.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getTrendingCategories: function getTrendingCategories(options, callback) {\n    if (!options) options = {};\n\n    return this._request({\n      api: '/reactions',\n      endpoint: '/populated',\n      method: 'GET',\n      query: {\n        gfyCount: options.gfyCount || 1,\n        cursor: options.cursor || null,\n        tagName: options.tagName || 'trending'\n      }\n    }, callback)\n  },\n\n  /**\n   * Retrieve JSON array of trending GIFs for a given tag.\n   * If no tag name is provided, the API returns overall trending GIFs.\n   *\n   * @param {Object} options\n   * @param {number} options.count - number of GIFs to include per category.\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {string} options.tagName - (optional) - name of the tag to get trending GIFs from.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getTrending: function getTrending(options, callback) {\n    if (!options) options = {};\n\n    return this._request({\n      api: '/gfycats',\n      endpoint: '/trending',\n      method: 'GET',\n      query: {\n        count: options.count || 100,\n        cursor: options.cursor || null,\n        tagName: options.tagName || null\n      }\n    }, callback);\n  },\n\n  /**\n   * Retrieve JSON array of trending tags.\n   *\n   * @param {Object} options\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getTrendingTags: function getTrendingTags(options, callback) {\n    if (!options) options = {};\n\n    return this._request({\n      api: '/tags',\n      endpoint: '/trending',\n      method: 'GET'\n    }, callback);\n  },\n\n  /**\n   * Retrieve JSON array of trending tags.\n   *\n   * @param {Object} options\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {number} options.gfyCount - total number of gifs to return for each tag.\n   * @param {number} options.tagCount - total number of tags to return.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getTrendingTagsPopulated: function getTrendingTagsPopulated(options, callback) {\n    if (!options) options = {};\n\n    return this._request({\n      api: '/tags',\n      endpoint: '/trending/populated',\n      method: 'GET',\n      query: {\n        count: options.count || 100,\n        cursor: options.cursor || null,\n        gfyCount: options.gfyCount || 1\n      }\n    }, callback);\n  },\n\n  /**\n   * Search all GIFs. For pagination, please only specify either cursor (& count), or count & start.\n   *\n   * @param {Object} options\n   * @param {string} options.search_text - search query term or phrase.\n   * @param {number} options.count - (optional) number of results to return, defaults to 100.\n   * @param {number} options.start - (optional) results offset, defaults to 0.\n   * @param {string} options.cursor - cursor for pagination.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  search: function(options, callback) {\n    return this._request({\n      api: '/gfycats',\n      endpoint: '/search',\n      method: 'GET',\n      query: {\n        search_text: options.search_text,\n        count: options.count || 100,\n        start: options.start || null,\n        cursor: options.cursor || null\n      }\n    }, callback);\n  },\n\n  /**\n   * Search a single gif by gfyId.\n   *\n   * @param {Object} options\n   * @param {string} options.id - gfycat id\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  searchById: function(options, callback) {\n    return this._request({\n      api: '/gfycats',\n      endpoint: '/' + options.id,\n      method: 'GET'\n    }, callback);\n  },\n\n  /**\n   * Get a list of gifs related to a given gif\n   *\n   * @param {Object} options\n   * @param {string} options.id - gfycat id\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  getRelatedContent: function(options, callback) {\n    return this._request({\n      api: '/gfycats',\n      endpoint: '/' + options.id + '/related',\n      method: 'GET',\n      query: {\n        cursor: options.cursor,\n        count: options.count,\n        from: options.from\n      }\n    }, callback);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {string} options.uploadKey - the key of the upload.\n   * @param {string[]} options.tags - the tags to associate with this gfycat\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  artifacts: function(options, callback) {\n    return this._request({\n      api: '/gifartifacts',\n      endpoint: '',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      method: 'POST',\n      payload: {\n        uploadKey: options.uploadKey,\n        tags: options.tags\n      }\n    }, callback);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {string} options.search_text - (optional) Search query\n   * @param {string} options.cursor - (optional) Cursor for pagination\n   * @param {number} options.count - (optional) Number of GIFs to return.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   */\n  stickers: function(options, callback) {\n    return this._request({\n      api: '/stickers',\n      endpoint: options.search_text ? '/search' : '',\n      method: 'GET',\n      query: {\n        cursor: options.cursor,\n        count: options.count,\n        search_text: options.search_text\n      }\n    });\n  },\n\n  /**\n   * Prepares the HTTP request and query string\n   *\n   * @param {Object} options\n   * @param {string} options.api - API type.\n   * @param {string} options.endpoint - The API method.\n   * @param {string} options.method - The http method to be used.\n   * @param {Object} options.payload - JSON data to be sent in POST requests.\n   * @param {Object} options.query - (optional) Query string parameters.\n   * @param {number} options.timeout - (optional) API timeout limit in milliseconds.\n   * @param {requestCallback} callback - (optional) callback function to run when the request completes.\n   * @ignore\n   */\n  _request: function(options, callback) {\n    if (!callback && !promisesExist) {\n      throw new Error('Callback must be provided if promises are unavailable');\n    }\n\n    if (typeof options === 'undefined' || !options) {\n      return _handleErr('Please provide valid options object', callback);\n    }\n\n    var counter = options.counter || 0;\n\n    if (counter >= this.retryLimit) {\n      if (callback) _handleErr('Retry limit reached', callback);\n      else return Promise.reject('Retry limit reached')\n    }\n\n    var token = this.access_token ?\n      'Bearer ' + this.access_token : null;\n\n    if (token) {\n      if (typeof options.headers === 'undefined') options.headers = {};\n      options.headers['Authorization'] = this.access_token;\n    }\n\n    var query = '';\n\n    if (typeof options.query === 'object' && Object.keys(options.query).length) {\n\n      // Omit null values from querystring\n      for (var key in options.query) {\n        // Using == intentionally to match null and undefined\n        if (options.query[key] == null) {\n          delete options.query[key]\n        }\n      }\n\n      query = '?' + queryString.stringify(options.query);\n    }\n\n    var httpOptions = {\n      request: {\n        headers: options.headers || null,\n        method: options.method,\n        payload: options.payload || null,\n        url: this.apiUrl + options.api + options.endpoint + query\n      },\n      timeout: options.timeout || this.timeout\n    };\n\n    var self = this;\n\n    if (callback) {\n      var resolve = function(res) {\n        callback(null, res);\n      };\n      var reject = function(err) {\n        if (err === 401 && options.api !== '/oauth') {\n          self.authenticate({}, function(err, res) {\n            if (err) callback(err);\n            else {\n              options.counter = counter + 1;\n              return self._request(options, callback);\n            }\n          })\n        } else {\n          callback(err);\n        }\n      };\n      httpService.request(httpOptions, resolve, reject);\n    }\n\n    else {\n      return new Promise(function(resolve, reject) {\n        httpService.request(httpOptions, resolve, reject)\n      })\n        .then(function(res) {\n          return Promise.resolve(res);\n        })\n        .catch(function(err) {\n          if (err === 401 && options.api !== '/oauth') {\n            return self.authenticate({})\n              .then(function(res) {\n                options.counter = counter + 1;\n                return self._request(options);\n              })\n              .catch(function(err) {\n                return Promise.reject(err);\n              });\n          } else {\n            return Promise.reject(err);\n          }\n        });\n    }\n  },\n\n  _setToken: function(options) {\n    this.access_token = options.access_token;\n    this.token_type = options.token_type;\n  }\n};\n\nmodule.exports = GfycatSDK;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/es5-gfycat-sdk.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}